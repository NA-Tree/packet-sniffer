#!/usr/bin/env python3
"""
sniff_analyze.py - Combined Wireshark-Lite (merged)

Features:
 - Interactive start/stop/status/detail/save/quit
 - BPF (libpcap) filter OR Python lfilter (proto/src/dst/ports)
 - DNS / SMTP / HTTP / TCP / UDP / ICMP detection
 - Live feed option, packet storage, and PCAP saving
 - Thread-safe analyzer & command thread

Usage:
  sudo python3 sniff_analyze.py
  python sniff_analyze.py --iface eth0 --bpf "tcp port 80" --out capture.pcap
"""

from __future__ import annotations
import argparse
import threading
import sys
import time
from collections import Counter, defaultdict
from datetime import datetime
from typing import Optional

from scapy.all import sniff, wrpcap, Raw, get_if_list
from scapy.layers.inet import IP, TCP, UDP, ICMP
from scapy.layers.dns import DNS

# ----------------------
# Helpers
# ----------------------
def pretty_bytes(n: int) -> str:
    for unit in ['B','KB','MB','GB']:
        if n < 1024.0:
            return f"{n:.1f}{unit}"
        n /= 1024.0
    return f"{n:.1f}TB"

def is_http_like(pkt) -> bool:
    """Detect HTTP by payload heuristics"""
    if TCP in pkt and Raw in pkt:
        try:
            s = bytes(pkt[Raw].load).decode('utf-8', errors='ignore')
            return s.startswith(('GET ','POST ','PUT ','DELETE ','HEAD ','OPTIONS ','HTTP/'))
        except Exception:
            return False
    return False

def interfaces_list() -> list:
    try:
        return get_if_list()
    except Exception:
        return []

def packet_summary_line(pkt, idx: Optional[int] = None) -> str:
    ts = datetime.fromtimestamp(getattr(pkt, "time", time.time())).strftime("%H:%M:%S.%f")[:-3]
    length = len(pkt) if hasattr(pkt, "__len__") else 0
    if IP in pkt:
        ip = pkt[IP]
        proto = "IP"
        extra = ""
        if is_http_like(pkt):
            proto = "HTTP"
        elif TCP in pkt:
            proto = "TCP"
            extra = f"{pkt[TCP].sport}->{pkt[TCP].dport}"
        elif UDP in pkt:
            proto = "UDP"
            extra = f"{pkt[UDP].sport}->{pkt[UDP].dport}"
        elif ICMP in pkt:
            proto = "ICMP"
        elif pkt.haslayer(DNS):
            proto = "DNS"
        s = f"{ts} {ip.src} -> {ip.dst} {proto}/{extra} {length}B"
    else:
        s = f"{ts} NON-IP {length}B"
    return f"[{idx}] {s}" if idx is not None else s

# ----------------------
# Analyzer (thread-safe)
# ----------------------
class Analyzer:
    def __init__(self):
        self.lock = threading.Lock()
        self.total = 0
        self.proto_counts = Counter()
        self.src_counts = Counter()
        self.dst_counts = Counter()
        self.tcp_flows = defaultdict(lambda: {'pkts':0,'bytes':0})
        self.http_samples = []   # small list of http first-lines
        self.packets = []        # stored packets for details / pcap

    def feed(self, pkt):
        with self.lock:
            self.total += 1
            self.packets.append(pkt)

            if IP in pkt:
                ip = pkt[IP]
                self.src_counts[ip.src] += 1
                self.dst_counts[ip.dst] += 1

                # DNS
                if pkt.haslayer(DNS):
                    self.proto_counts['DNS'] += 1
                    # attempt to store qname if present
                    try:
                        if getattr(pkt[DNS], 'qd', None):
                            qname = pkt[DNS].qd.qname.decode(errors='ignore')
                            # store small sample
                            if len(self.http_samples) < 20:
                                self.http_samples.append(("DNS", ip.src, ip.dst, qname))
                    except Exception:
                        pass

                # HTTP detection
                elif is_http_like(pkt):
                    self.proto_counts['HTTP'] += 1
                    try:
                        first = bytes(pkt[Raw].load).decode('utf-8', errors='ignore').splitlines()[0]
                        if len(self.http_samples) < 20:
                            self.http_samples.append(("HTTP", ip.src, ip.dst, first))
                    except Exception:
                        pass

                # SMTP (simple port-based detection)
                elif TCP in pkt and (pkt[TCP].sport == 25 or pkt[TCP].dport == 25 or pkt[TCP].sport == 587 or pkt[TCP].dport == 587):
                    self.proto_counts['SMTP'] += 1

                elif TCP in pkt:
                    self.proto_counts['TCP'] += 1
                    tcp = pkt[TCP]
                    key = (ip.src, tcp.sport, ip.dst, tcp.dport)
                    self.tcp_flows[key]['pkts'] += 1
                    self.tcp_flows[key]['bytes'] += len(pkt)

                elif UDP in pkt:
                    self.proto_counts['UDP'] += 1

                elif ICMP in pkt:
                    self.proto_counts['ICMP'] += 1

                else:
                    self.proto_counts[f"IP_PROTO_{ip.proto}"] += 1
            else:
                self.proto_counts['NON_IP'] += 1

    def snapshot(self):
        with self.lock:
            return {
                'total': self.total,
                'proto_counts': self.proto_counts.most_common(),
                'top_src': self.src_counts.most_common(8),
                'top_dst': self.dst_counts.most_common(8),
                'top_flows': sorted(self.tcp_flows.items(), key=lambda kv: kv[1]['pkts'], reverse=True)[:10],
                'http_samples': list(self.http_samples)[:10],
                'packets_count': len(self.packets)
            }

    def report(self):
        snap = self.snapshot()
        print("\n=== Capture Summary ===")
        print(f"Total packets: {snap['total']}")
        print("\nTop protocols:")
        for proto, cnt in snap['proto_counts']:
            print(f"  {proto:12s} : {cnt}")
        print("\nTop source IPs:")
        for ip,c in snap['top_src']:
            print(f"  {ip:16s} : {c}")
        print("\nTop destination IPs:")
        for ip,c in snap['top_dst']:
            print(f"  {ip:16s} : {c}")
        print("\nTop TCP flows:")
        for (s,sport,d,dport), stats in snap['top_flows']:
            print(f"  {s}:{sport} -> {d}:{dport}  pkts={stats['pkts']}  bytes={pretty_bytes(stats['bytes'])}")
        if snap['http_samples']:
            print("\nPayload samples (HTTP/DNS):")
            for kind, src, dst, sample in snap['http_samples']:
                print(f"  {kind} {src} -> {dst}  {sample}")

# ----------------------
# Filter builder
# ----------------------
def build_lfilter(proto=None, src=None, dst=None, sport=None, dport=None):
    proto = proto.lower() if proto else None
    def lfilter(pkt):
        try:
            if IP not in pkt:
                if proto or src or dst or sport or dport:
                    return False
                return True
            ip = pkt[IP]
            if src and ip.src != src:
                return False
            if dst and ip.dst != dst:
                return False
            if proto:
                if proto == 'tcp' and TCP not in pkt:
                    return False
                if proto == 'udp' and UDP not in pkt:
                    return False
                if proto == 'dns' and not pkt.haslayer(DNS):
                    return False
                if proto == 'http' and not is_http_like(pkt):
                    return False
            if sport:
                try:
                    s = int(sport)
                except Exception:
                    return False
                if TCP in pkt and pkt[TCP].sport != s:
                    return False
                if UDP in pkt and pkt[UDP].sport != s:
                    return False
            if dport:
                try:
                    d = int(dport)
                except Exception:
                    return False
                if TCP in pkt and pkt[TCP].dport != d:
                    return False
                if UDP in pkt and pkt[UDP].dport != d:
                    return False
            return True
        except Exception:
            return False
    return lfilter

# ----------------------
# Sniffer controller
# ----------------------
class SnifferController:
    def __init__(self, iface=None, bpf:Optional[str]=None, proto=None, src=None, dst=None, sport=None, dport=None, liveFeed=None):
        self.iface = iface
        self.bpf = bpf
        self.lfilter = None if bpf else build_lfilter(proto, src, dst, sport, dport)
        self.analyzer = Analyzer()
        self._run_flag = threading.Event()  # capture running when set
        self._stop_event = threading.Event() # to request thread exit
        self._sniff_thread = None
        self.liveFeed = liveFeed
        self._store_lock = threading.Lock()

    def _process(self, pkt):
        # Called for each packet
        # feed analyzer and optionally print a concise live line
        self.analyzer.feed(pkt)
        if self.liveFeed and str(self.liveFeed).lower() != "no":
            idx = len(self.analyzer.packets)
            try:
                # concise one-line live feed
                print(packet_summary_line(pkt, idx))
            except Exception:
                pass

    def _sniff_loop(self):
        # Use sniff with short timeout loops so start/stop is responsive
        try:
            while not self._stop_event.is_set():
                if not self._run_flag.is_set():
                    time.sleep(0.2)
                    continue
                sniff_kwargs = {
                    'prn': self._process,
                    'store': False,
                    'timeout': 1.0
                }
                if self.iface:
                    sniff_kwargs['iface'] = self.iface
                if self.bpf:
                    sniff_kwargs['filter'] = self.bpf
                else:
                    sniff_kwargs['lfilter'] = self.lfilter
                try:
                    sniff(**sniff_kwargs)
                except Exception as e:
                    # show a short message but keep retrying
                    print(f"[sniff error] {e}")
                    time.sleep(0.5)
        finally:
            # thread exit
            pass

    def start_capture_thread(self):
        if self._sniff_thread and self._sniff_thread.is_alive():
            return
        self._stop_event.clear()
        self._sniff_thread = threading.Thread(target=self._sniff_loop, daemon=True)
        self._sniff_thread.start()

    def start(self):
        self._run_flag.set()

    def stop(self):
        self._run_flag.clear()

    def shutdown(self):
        self._stop_event.set()
        self._run_flag.clear()
        if self._sniff_thread:
            self._sniff_thread.join(timeout=2)

    def save_pcap(self, filename: str):
        with self.analyzer.lock:
            if not self.analyzer.packets:
                print("No packets to save.")
                return False
            try:
                wrpcap(filename, self.analyzer.packets)
                print(f"Saved {len(self.analyzer.packets)} packets to {filename}")
                return True
            except Exception as e:
                print(f"Failed to save pcap: {e}")
                return False

    def show_status(self):
        self.analyzer.report()

    def show_detail(self, idx: int):
        with self.analyzer.lock:
            if idx < 0 or idx >= len(self.analyzer.packets):
                print(f"Invalid index {idx}; total stored = {len(self.analyzer.packets)}")
                return
            pkt = self.analyzer.packets[idx]
        # print a concise summary and then the full scapy show()
        print("\n=== Packet Detail ===")
        print(packet_summary_line(pkt, idx))
        try:
            pkt.show()
        except Exception as e:
            print(f"(Could not show packet details: {e})")
        print("=====================\n")

# ----------------------
# Command thread
# ----------------------
def command_thread_fn(controller: SnifferController):
    print("Interactive commands: start | stop | status | save <file.pcap> | detail <N> | iface | iflist | quit")
    while True:
        try:
            cmd_line = input("> ").strip()
        except EOFError:
            break
        if not cmd_line:
            continue
        parts = cmd_line.split()
        cmd = parts[0].lower()
        if cmd == 'start':
            controller.start()
            print("Capture started.")
        elif cmd == 'stop':
            controller.stop()
            print("Capture stopped.")
        elif cmd == 'status':
            controller.show_status()
        elif cmd == 'save':
            if len(parts) < 2:
                print("Usage: save filename.pcap")
                continue
            controller.save_pcap(parts[1])
        elif cmd == 'detail':
            if len(parts) < 2:
                print("Usage: detail N")
                continue
            try:
                n = int(parts[1])
            except ValueError:
                print("Invalid index")
                continue
            controller.show_detail(n)
        elif cmd == 'iface':
            print(f"Current interface: {controller.iface}")
        elif cmd == 'iflist':
            print("Available interfaces:", ", ".join(interfaces_list()))
        elif cmd == 'quit':
            print("Quitting...")
            controller.shutdown()
            break
        else:
            print("Unknown command. Valid: start stop status save detail iface iflist quit")

# ----------------------
# Packet summary (detailed) for printing
# ----------------------
def packet_summary(pkt):
    ts = datetime.fromtimestamp(getattr(pkt, "time", time.time())).isoformat()
    length = len(pkt) if hasattr(pkt, "__len__") else 0
    lines = [f"Timestamp: {ts}", f"Length: {length} bytes"]
    if IP in pkt:
        ip = pkt[IP]
        lines.append(f"IP {ip.src} -> {ip.dst}")
        if pkt.haslayer(DNS):
            dns = pkt[DNS]
            lines.append(f"DNS id={getattr(dns,'id',None)} qdcount={getattr(dns,'qdcount',None)} ancount={getattr(dns,'ancount',None)}")
            try:
                if getattr(dns,'qd',None):
                    lines.append(f" Query: {dns.qd.qname.decode(errors='ignore')}")
            except Exception:
                pass
        elif TCP in pkt and (pkt[TCP].sport == 25 or pkt[TCP].dport == 25):
            lines.append("SMTP (port-based) detected")
        elif is_http_like(pkt):
            lines.append("HTTP-like payload")
        elif TCP in pkt:
            t = pkt[TCP]
            lines.append(f"TCP sport={t.sport} dport={t.dport} seq={getattr(t,'seq',None)} ack={getattr(t,'ack',None)} flags={getattr(t,'flags',None)}")
        elif UDP in pkt:
            u = pkt[UDP]
            lines.append(f"UDP sport={u.sport} dport={u.dport}")
        elif ICMP in pkt:
            ic = pkt[ICMP]
            lines.append(f"ICMP type={ic.type} code={ic.code}")
    else:
        lines.append("Non-IP packet")
    return "\n".join(lines)

# ----------------------
# Main
# ----------------------
def interactive_prompts():
    print("Available interfaces:", ", ".join(interfaces_list()))
    iface = input("Interface (blank for default): ").strip() or None
    bpf = input("BPF filter (leave blank to use simple filters): ").strip() or None
    proto = src = dst = sport = dport = None
    if not bpf:
        proto = input("Proto (tcp/udp/ip/dns/http) or blank: ").strip() or None
        src = input("Source IP or blank: ").strip() or None
        dst = input("Dest IP or blank: ").strip() or None
        sport = input("Source port or blank: ").strip() or None
        dport = input("Dest port or blank: ").strip() or None
    out = input("Save to pcap filename on exit (leave blank to skip): ").strip() or None
    liveFeed = input("Live feed? (yes/no, default yes): ").strip() or "yes"
    return iface, bpf, proto, src, dst, sport, dport, out, liveFeed

def main():
    parser = argparse.ArgumentParser(description="Packet Sniffer with Analysis (Wireshark-Lite)")
    parser.add_argument('--iface', '-i', help='Interface to capture on', default=None)
    parser.add_argument('--bpf', help='BPF/libpcap filter string (optional)', default=None)
    parser.add_argument('--proto', help='Python-level proto filter: tcp/udp/dns/http', default=None)
    parser.add_argument('--src', help='Source IP Python filter', default=None)
    parser.add_argument('--dst', help='Dest IP Python filter', default=None)
    parser.add_argument('--sport', help='Source port Python filter', default=None)
    parser.add_argument('--dport', help='Dest port Python filter', default=None)
    parser.add_argument('--out', help='Write capture to pcap file on exit', default=None)
    args = parser.parse_args()

    if len(sys.argv) == 1:
        iface, bpf, proto, src, dst, sport, dport, out, liveFeed = interactive_prompts()
    else:
        iface = args.iface
        bpf = args.bpf
        proto = args.proto
        src = args.src
        dst = args.dst
        sport = args.sport
        dport = args.dport
        out = args.out
        liveFeed = "yes"

    controller = SnifferController(iface=iface, bpf=bpf, proto=proto, src=src, dst=dst, sport=sport, dport=dport, liveFeed=liveFeed)
    controller.start_capture_thread()
    controller.start()
    # start command thread
    cmd_thread = threading.Thread(target=command_thread_fn, args=(controller,), daemon=True)
    cmd_thread.start()

    try:
        while cmd_thread.is_alive():
            cmd_thread.join(timeout=0.5)
    except KeyboardInterrupt:
        print("\nKeyboardInterrupt received. Shutting down.")
        controller.shutdown()

    if out:
        controller.save_pcap(out)

if __name__ == "__main__":
    main()
